#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    rightMGL,       sensorPotentiometer)
#pragma config(Sensor, in2,    leftMGL,        sensorPotentiometer)
#pragma config(Sensor, dgtl5,  leftSideDist,   sensorSONAR_inch)
#pragma config(Sensor, dgtl7,  rightDT,        sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  clawTiltAngle,  sensorQuadEncoder)
#pragma config(Sensor, dgtl11, leftDT,         sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  leftLift,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  rightLift,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           claw,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           frontRightDT,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           frontLeftDT,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightMGLift,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftConeLift,  tmotorVex393_MC29, PIDControl, encoderPort, I2C_1)
#pragma config(Motor,  port6,           rightConeLift, tmotorVex393_MC29, PIDControl, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port7,           leftMGLift,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           backLeftDT,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           backRightDT,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          tiltClaw,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#define LEFT_MGL_BOTTOM  1478;
#define RIGHT_MGL_BOTTOM  2378;

#define LEFT_MGL_TOP  293;
#define RIGHT_MGL_TOP  3810;

#define LEFT_MGL_LOW_BAR 1340
#define RIGHT_MGL_LOW_BAR  2740

#define LEFT_MGL_HIGH_BAR 1116
#define RIGHT_MGL_HIGH_BAR 2900

int deadzone = 5;
int mglMax = 0;
int mglMin = -45;

bool clawLocked = false;
bool btn7ROld = false;
bool Btn8DXmtr2Old = false;

int tiltAngle;
int liftAngle;

bool keepClawLevel = false;
int clawTarget = 0;
int clawError;
int startErrorClaw;
int tiltMotorSpeed = 0;
float kpClaw = 1.0;

int liftError;
int liftTarget = 0;
int liftMotorSpeed;
float kpLift = 0.0;

int rightMGLError;
int rightMGLAngle;
int leftMGLError;
int leftMGLAngle;
int leftMGLSpeed;
int rightMGLSpeed;
int leftMGLTarget = LEFT_MGL_TOP;
int rightMGLTarget = RIGHT_MGL_TOP;
float kpMglLift = 0.25;

bool mglPControlIsRunning = false;
bool mglAllowPControl = true;

bool allowPControl = true;
bool pControlIsRunning = true;

int firstLift = 0;
int firstTilt = 0;

int secondLift = 0;
int secondTilt = 0;

int thirdLift = 0;
int thirdTilt = 0;

int fourthLift = 0;
int fourthTilt = 0;

int groundPickUpCone = 0;
int preloadPickUpCone = 0;

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*---------------------------------------------------------------------------*/
void pre_auton()
{
	bStopTasksBetweenModes = true;
}

void raiseMGLift(){
	motor[leftMGLift] = 60;
	motor[rightMGLift] = 60;
}

void stopMGLift(){
	motor[leftMGLift] = 0;
	motor[rightMGLift] = 0;
}

void lowerMGLift(){
	motor[leftMGLift] = -30;
	motor[rightMGLift] = -30;
}

void raiseConeLift(){
	motor[rightConeLift] = 110;
	motor[leftConeLift] = 110;
}

void lowerConeLift(){
	motor[rightConeLift] = -110;
	motor[leftConeLift] = -110;
}
void stopConeLift(){
	motor[rightConeLift] = 0;
	motor[leftConeLift] = 0;
}

void openClaw(){
	motor[claw] = 75;
}
void closeClaw(){
	motor[claw] = -75;
}
void lockClaw(){
	motor[claw] = -50;
}
void stopClaw(){
	motor[claw] = 0;
}

void clawForward(){
	motor[tiltClaw] = 127;
}
void clawBackward(){
	motor[tiltClaw] = -127;
}
void stopTilt(){
	motor[tiltClaw] = 0;
}

int inchesToTicks(float inches){
	float numberOfRotations = inches / (2.0 * PI * 4.0);
	int numTicks = numberOfRotations * 90;
	return numTicks;
}

//////////////////////////////////////////////////////////////
// Apply an exponential transformation to the joystick,     //
// allowing for fine control at low values while still      //
// providing full speed control.                            //
//                                                          //
// Motor Speed = 14.1111 * (10^(Input Value/127)) - 14.1111 //
//////////////////////////////////////////////////////////////
int transformJoystick(int joyValue){
	if (abs(joyValue) < deadzone){
		return 0;
	}

	bool isPositive = true;
	if (joyValue < 0){
		isPositive = false;
	}

	int finalSpeed = (127.0/9.0) * pow(10.0, (abs(joyValue) / 127.0)) - (127.0/9.0);

	if (!isPositive){
		finalSpeed *= -1;
	}
	return finalSpeed;
}

//////////////////////////////////////////
// Conversions for Claw Tilt Controller //
//////////////////////////////////////////

int clawTiltEncoderToLiftEncoder(int clawTiltValue){
	int convertedValue = (1960.0 * clawTiltValue) / 180;
	return convertedValue;
}

/*-----PID Lift Control-----*/

task mglControl(){
	mglPControlIsRunning = true;
	while (true){
		rightMGLAngle = SensorValue(rightMGL);
		leftMGLAngle = SensorValue(leftMGL);

		rightMGLError = -1 * (rightMGLAngle - rightMGLTarget);

		rightMGLSpeed = kpMglLift * rightMGLError;
		leftMGLSpeed = kpMglLift * rightMGLError;

		if (leftMGLSpeed > 80){
			leftMGLSpeed = 80;
		}
		if (leftMGLSpeed < -40){
			leftMGLSpeed = -40;
		}

		if (rightMGLSpeed > 80){
			rightMGLSpeed = 80;
		}
		if (rightMGLSpeed < -40){
			rightMGLSpeed = -40;
		}

		motor[leftMGLift] = leftMGLSpeed;
		motor[rightMGLift] = rightMGLSpeed;

		sleep(20);
	}
}

bool controlConeLift = false;
bool allowControlConeLift = false;

task liftControl(){
	tiltAngle = -1 * clawTiltEncoderToLiftEncoder(SensorValue(clawTiltAngle));
	liftAngle = SensorValue(leftLift);

	startErrorClaw = tiltAngle - liftAngle;
	pControlIsRunning = true;

	while (true){
		tiltAngle = -1 * clawTiltEncoderToLiftEncoder(SensorValue(clawTiltAngle));
		liftAngle = SensorValue(leftLift);
		if (keepClawLevel){
			clawError = tiltAngle - liftAngle - startErrorClaw;
		}
		if (controlConeLift){
			liftError = liftAngle - liftTarget;
			liftMotorSpeed = kpLift * liftError;
		}

		tiltMotorSpeed = kpClaw * clawError;

		if (tiltMotorSpeed > 127){
			tiltMotorSpeed = 127;
		}
		else if (tiltMotorSpeed < -127){
			tiltMotorSpeed = -127;
		}

		if (liftMotorSpeed > 127){
			liftMotorSpeed = 127;
		}
		else if (tiltMotorSpeed < -127){
			liftMotorSpeed = -127;
		}

		motor[tiltClaw] = tiltMotorSpeed;
		//motor[leftConeLift] = liftMotorSpeed;
		//motor[rightConeLift] = liftMotorSpeed;

		sleep(20);
	}
}

float inchesToDrive = 0.0;

int leftDTTarget;
int rightDTTarget;

int leftDTPos;
int rightDTPos;
int leftDTError;
int rightDTError;
int leftDTSpeed;
int rightDTSpeed;
float kpDt = 0.0;

task driveControl(){
	leftDTPos = SensorValue(leftDT);
	rightDTPos = SensorValue(rightDTPos);

	leftDTTarget = leftDTPos + inchesToTicks(inchesToDrive);
	rightDTTarget = rightDTPos + inchesToTicks(inchesToDrive);

	while (true){
		leftDTPos = SensorValue(leftDT);
		rightDTPos = SensorValue(rightDT);

		leftDTError = leftDTTarget - leftDTPos + (rightDTPos - leftDTPos);
		rightDTError = rightDTTarget - rightDTPos;

		leftDTSpeed = kpDt * leftDTError;
		rightDTSpeed = kpDt * rightDTError;

		if (leftDTSpeed > 127){
			leftDTSpeed = 127;
		}
		if (leftDTSpeed < -127){
			leftDTSpeed = -127;
		}

		if (rightDTSpeed > 100){
			rightDTSpeed = 100;
		}
		if (rightDTSpeed < -100){
			leftDTSpeed = -100;
		}

		motor[frontLeftDT] = leftDTSpeed;
		motor[backLeftDT] = leftDTSpeed;

		motor[frontRightDT] = rightDTSpeed;
		motor[backRightDT] = rightDTSpeed;

		if (abs(leftDTError) < 10 && abs(rightDTError) < 10){
			break;
		}

		sleep(20);
	}
}

/*-----Autonomous-----*/

int autonomousMode = 0;

task autonomous()
{
	playSoundFile("music.wav");

	if (autonomousMode == 1){}

	if (autonomousMode == 2){}

	if (autonomousMode == 3){}

	if (autonomousMode == 4){}

	if (autonomousMode == 5){}

	if (autonomousMode == 6){}

}

/*-----Driver Control-----*/
task usercontrol()
{
	startTask(liftControl);
	startTask(mglControl);
	while (true)
	{
		int leftStick = transformJoystick(vexRT[Ch3]);
		int rightStick = transformJoystick(vexRT[Ch2]);

		motor[frontLeftDT] = leftStick;
		motor[backLeftDT] = leftStick;

		motor[frontRightDT] = rightStick;
		motor[backRightDT] = rightStick;

		if (vexRT[Btn5U] == 1){
			if (mglPControlIsRunning){
				stopTask(mglControl);
				mglPControlIsRunning = false;
			}
			raiseMGLift();
		}
		else if (vexRT[Btn5D] == 1){
			if (mglPControlIsRunning){
				stopTask(mglControl);
				mglPControlIsRunning = false;
			}
			lowerMGLift();
		}

		else{
			if (!mglPControlIsRunning){
				if (mglAllowPControl){
					stopMGLift();
					wait1Msec(40);
					leftMGLTarget = SensorValue(leftMGL);
					rightMGLTarget = SensorValue(rightMGL);
					startTask(mglControl);
				}
				else{
					stopMGLift();
				}
			}
		}

		if (vexRT[Btn6D] == 1){
			raiseConeLift();
		}

		if (vexRT[Btn6U] == 1){
			lowerConeLift();
		}

		if (vexRT[Btn6U] == 0 && vexRT[Btn6D] == 0) {
			stopConeLift();
		}

		if (vexRT[Btn7UXmtr2] == 1){
			openClaw();
			clawLocked = false;
		}
		else if (vexRT[Btn7LXmtr2] == 1){
			closeClaw();
			clawLocked = false;
		}
		else if (vexRT[Btn7RXmtr2] == 1 && !btn7ROld){
			btn7ROld = true;
			if (!clawLocked){
				clawLocked = true;
				lockClaw();
			}
			else{
				clawLocked = false;
			}
		}
		else if (!clawLocked) {
			stopClaw();
		}

		if (vexRT[Btn7R] == 0){
			btn7ROld = false;
		}

		// Stop/Start P-Control

		if (vexRT[Btn8DXmtr2] == 1 && !Btn8DXmtr2Old){
			Btn8DXmtr2Old = true;
			if (pControlIsRunning){
				stopTask(liftControl);
				pControlIsRunning = false;
				allowPControl = false;
			}
			else{
				startTask(liftControl);
				allowPControl = true;
			}
		}

		if (vexRT[Btn8DXmtr2] == 0 && Btn8DXmtr2Old){
			Btn8DXmtr2Old = false;
		}

		if (vexRT[Btn5UXmtr2] == 1){
			leftMGLTarget = LEFT_MGL_TOP;
			rightMGLTarget = RIGHT_MGL_TOP;
		}

		if (vexRT[Btn5DXmtr2] == 1){
			leftMGLTarget = LEFT_MGL_BOTTOM;
			rightMGLTarget = RIGHT_MGL_BOTTOM;
		}

		if (vexRT[Btn8UXmtr2] == 1){
			leftMGLTarget = LEFT_MGL_HIGH_BAR;
			rightMGLTarget = RIGHT_MGL_HIGH_BAR;
		}
		if (vexRT[Btn8LXmtr2] == 1){
			leftMGLTarget = LEFT_MGL_LOW_BAR;
			rightMGLTarget = RIGHT_MGL_LOW_BAR;
		}


		// Manually override claw tilt p-control
		if (vexRT[Btn6UXmtr2] == 1){
			if (pControlIsRunning){
				stopTask(liftControl);
				pControlIsRunning = false;
			}
			clawForward();
		}
		else if (vexRT[Btn6DXmtr2] == 1){
			if (pControlIsRunning){
				stopTask(liftControl);
				pControlIsRunning = false;
			}
			clawBackward();
		}
		else{
			if (allowPControl && !pControlIsRunning){
				if (!keepClawLevel){
					clawTarget = SensorValue(clawTiltAngle);
				}
				startTask(liftControl);

			}
			if (!allowPControl){
				stopTilt();
			}
		}
	}
}
