#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl9,  clawTiltAngle,  sensorQuadEncoder)
#pragma config(Sensor, dgtl11, mglLeft,        sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  leftLift,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  rightLift,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           claw,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           frontRightDT,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           frontLeftDT,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightMGLift,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftConeLift,  tmotorVex393_MC29, PIDControl, encoderPort, I2C_1)
#pragma config(Motor,  port6,           rightConeLift, tmotorVex393_MC29, PIDControl, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port7,           leftMGLift,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           backLeftDT,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           backRightDT,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          tiltClaw,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

int deadzone = 5;
int mglMax = 0;
int mglMin = -45;

bool clawLocked = false;
bool btn7ROld = false;
bool Btn8DXmtr2Old = false;

int tiltAngle;
int liftAngle;
int error;
int startError;
int tiltMotorSpeed = 0;
float kp = 1.0;
bool allowPControl = true;
bool pControlIsRunning = true;

/*
float liftTarget = 0;
float coneLiftLeft;
float coneLiftRight;
float leftError = 0;
float rightError = 0;
float lastLeftError = 0;
float lastRightError = 0;

float kP = .5;
float kI = 0.0;
float kD = 0.0;

float integralLimit = 20;

float integralLeft = 0;
float derivativeLeft = 0;

float integralRight = 0;
float derivativeRight = 0;

float leftLiftSpeed = 0;
float rightLiftSpeed = 0;
*/
bool isPlaying = false;

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

void raiseMGLift(){
	motor[leftMGLift] = 60;
	motor[rightMGLift] = 60;
}

void stopMGLift(){
	motor[leftMGLift] = 10; //REMEMBER TO CHANGE BACK!!!
	motor[rightMGLift] = 10;
}

void lowerMGLift(){
	motor[leftMGLift] = -30;
	motor[rightMGLift] = -30;
}

void raiseConeLift(){
	motor[rightConeLift] = 110;
	motor[leftConeLift] = 110;
}

void lowerConeLift(){
	motor[rightConeLift] = -110;
	motor[leftConeLift] = -110;
}
void stopConeLift(){
	motor[rightConeLift] = 0;
	motor[leftConeLift] = 0;
}

void openClaw(){
	motor[claw] = 75;
}
void closeClaw(){
	motor[claw] = -75;
}
void lockClaw(){
	motor[claw] = -50;
}
void stopClaw(){
	motor[claw] = 0;
}

void clawForward(){
	motor[tiltClaw] = 127;
}
void clawBackward(){
	motor[tiltClaw] = -127;
}
void stopTilt(){
	motor[tiltClaw] = 0;
}

//////////////////////////////////////////////////////////////
// Apply an exponential transformation to the joystick,     //
// allowing for fine control at low values while still      //
// providing full speed control.                            //
//                                                          //
// Motor Speed = 14.1111 * (10^(Input Value/127)) - 14.1111 //
//////////////////////////////////////////////////////////////
int transformJoystick(int joyValue){
	if (abs(joyValue) < deadzone){
		return 0;
	}

	bool isPositive = true;
	if (joyValue < 0){
		isPositive = false;
	}

	int finalSpeed = (127.0/9.0) * pow(10.0, (abs(joyValue) / 127.0)) - (127.0/9.0);

	if (!isPositive){
		finalSpeed *= -1;
	}
	return finalSpeed;
}

//////////////////////////////////////////
// Conversions for Claw Tilt Controller //
//////////////////////////////////////////

int clawTiltEncoderToLiftEncoder(int clawTiltValue){
	int convertedValue = (1960.0 * clawTiltValue) / 180;
	return convertedValue;
}

/*-----PID Lift Control-----*/


task liftControl(){
	tiltAngle = -1 * clawTiltEncoderToLiftEncoder(SensorValue(clawTiltAngle));
	liftAngle = SensorValue(leftLift);
	startError = tiltAngle - liftAngle;
	pControlIsRunning = true;
	while (true){
		tiltAngle = -1 * clawTiltEncoderToLiftEncoder(SensorValue(clawTiltAngle));
		liftAngle = SensorValue(leftLift);
		error = tiltAngle - liftAngle - startError;

		tiltMotorSpeed = kp * error;

		if (tiltMotorSpeed > 127){
			tiltMotorSpeed = 127;
		}
		else if (tiltMotorSpeed < -127){
			tiltMotorSpeed = -127;
		}
		motor[tiltClaw] = tiltMotorSpeed;
		sleep(20);
	}
}


/*-----Autonomous-----*/

task autonomous()
{
	/*playSoundFile("music.wav");
	lockClaw();
	raiseConeLift();
	while (SensorValue[rightLift] < 500){}
	stopConeLift();

	lowerMGLift();
	while (SensorValue[mglLeft] > mglMin){}
	stopMGLift();

	motor[frontRightDT] = 127;
	motor[frontLeftDT] = 72;
	motor[backRightDT] = 127;
	motor[backLeftDT] = 72;
	wait1Msec(2500);
	motor[frontRightDT] = 0;
	motor[frontLeftDT] = 0;

	motor[backRightDT] = 0;
	motor[backLeftDT] = 0;

	lowerConeLift();
	while (SensorValue[rightLift] > 200){}
	stopConeLift();

	openClaw();
	wait1Msec(500);
	stopClaw();

	raiseConeLift();
	while (SensorValue[rightLift] < 500){}
	stopConeLift();

	motor[frontRightDT] = -50;
	motor[frontLeftDT] = -50;

	motor[backRightDT] = -50;
	motor[backLeftDT] = -50;
	wait1Msec(1000);

	motor[frontRightDT] = 0;
	motor[frontLeftDT] = 0;

	motor[backRightDT] = 0;
	motor[backLeftDT] = 0;*/
}

/*-----Driver Control-----*/
task usercontrol()
{
	startTask(liftControl);
	while (true)
	{
		int leftStick = transformJoystick(vexRT[Ch3]);
		int rightStick = transformJoystick(vexRT[Ch2]);

		motor[frontLeftDT] = leftStick;
		motor[backLeftDT] = leftStick;

		motor[frontRightDT] = rightStick;
		motor[backRightDT] = rightStick;

		if (vexRT[Btn5U] == 1 && SensorValue[mglLeft] <= mglMax){
			raiseMGLift();
		}
		else if (vexRT[Btn5D] == 1 && SensorValue[mglLeft] >= mglMin){
			lowerMGLift();
		}
		else if (vexRT[Btn8D] == 1){
			lowerMGLift();
		}
		else if (vexRT[Btn8R] == 1){
			raiseMGLift();
		}
		else{
			stopMGLift();
		}

		if (vexRT[Btn6D] == 1){
			raiseConeLift();
		}

		if (vexRT[Btn6U] == 1){
			lowerConeLift();
		}

		if (vexRT[Btn6U] == 0 && vexRT[Btn6D] == 0) {
			stopConeLift();
		}

		if (vexRT[Btn7UXmtr2] == 1){
			openClaw();
			clawLocked = false;
		}
		else if (vexRT[Btn7LXmtr2] == 1){
			closeClaw();
			clawLocked = false;
		}
		else if (vexRT[Btn7RXmtr2] == 1 && !btn7ROld){
			btn7ROld = true;
			if (!clawLocked){
				clawLocked = true;
				lockClaw();
			}
			else{
				clawLocked = false;
			}
		}
		else if (!clawLocked) {
			stopClaw();
		}

		if (vexRT[Btn7R] == 0){
			btn7ROld = false;
		}

		// Stop/Start P-Control

		if (vexRT[Btn8DXmtr2] == 1 && !Btn8DXmtr2Old){
			Btn8DXmtr2Old = true;
			if (pControlIsRunning){
				stopTask(liftControl);
				pControlIsRunning = false;
				allowPControl = false;
			}
			else{
				startTask(liftControl);
				allowPControl = true;
			}
		}

		if (vexRT[Btn8DXmtr2] == 0 && Btn8DXmtr2Old){
			Btn8DXmtr2Old = false;
		}

		// Manually override claw tilt p-control
		if (vexRT[Btn6UXmtr2] == 1){
			if (pControlIsRunning){
				stopTask(liftControl);
				pControlIsRunning = false;
			}
			clawForward();
		}
		else if (vexRT[Btn6DXmtr2] == 1){
			if (pControlIsRunning){
				stopTask(liftControl);
				pControlIsRunning = false;
			}
			clawBackward();
		}
		else{
			if (allowPControl && !pControlIsRunning){
				startTask(liftControl);
			}
			if (!allowPControl){
				stopTilt();
			}
		}
	}
}
