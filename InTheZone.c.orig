#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    rightMGL,       sensorPotentiometer)
#pragma config(Sensor, in2,    leftMGL,        sensorPotentiometer)
#pragma config(Sensor, dgtl5,  leftSideDist,   sensorSONAR_inch)
#pragma config(Sensor, dgtl7,  rightDT,        sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  clawTiltAngle,  sensorQuadEncoder)
#pragma config(Sensor, dgtl11, leftDT,         sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  leftLift,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  rightLift,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           claw,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           frontRightDT,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           frontLeftDT,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightMGLift,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftConeLift,  tmotorVex393_MC29, PIDControl, encoderPort, I2C_1)
#pragma config(Motor,  port6,           rightConeLift, tmotorVex393_MC29, PIDControl, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port7,           leftMGLift,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           backLeftDT,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           backRightDT,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          tiltClaw,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#define MGL_FLOOR = 0.0;
#define MGL_RETRACT = 0.0;
#define MGL_LOW_BAR = 0.0;
#define MGL_HIGH_BAR = 0.0;

int deadzone = 5;
int mglMax = 0;
int mglMin = -45;

bool clawLocked = false;
bool btn7ROld = false;
bool Btn8DXmtr2Old = false;

int tiltAngle;
int liftAngle;

bool keepClawLevel = false;
int clawTarget = 0;
int clawError;
int startErrorClaw;
int tiltMotorSpeed = 0;
float kpClaw = 1.0;

int liftError;
int liftTarget = 0;
int liftMotorSpeed;
float kpLift = 0.0;

<<<<<<< HEAD
bool allowPControl = false;
bool pControlIsRunning = false;
=======
int mglTarget;
int rightMGLError;
int rightMGLAngle;
int leftMGLError;
int leftMGLAngle;
int leftMGLSpeed;
int rightMGLSpeed;
float kpMglLift = 0.25;

bool mglPControlIsRunning = false;
bool mglAllowPControl = true;

bool allowPControl = true;
bool pControlIsRunning = true;
>>>>>>> 6a2d3c03272651c862c30c8c9c012e92b8cfbc0e

int firstLift = 0;
int firstTilt = 0;

int secondLift = 0;
int secondTilt = 0;

int thirdLift = 0;
int thirdTilt = 0;

int fourthLift = 0;
int fourthTilt = 0;

int groundPickUpCone = 0;
int preloadPickUpCone = 0;


/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

void raiseMGLift(){
	motor[leftMGLift] = 60;
	motor[rightMGLift] = 60;
}

void stopMGLift(){
	motor[leftMGLift] = 0;
	motor[rightMGLift] = 0;
}

void lowerMGLift(){
	motor[leftMGLift] = -30;
	motor[rightMGLift] = -30;
}

void raiseConeLift(){
	motor[rightConeLift] = 110;
	motor[leftConeLift] = 110;
}

void lowerConeLift(){
	motor[rightConeLift] = -110;
	motor[leftConeLift] = -110;
}
void stopConeLift(){
	motor[rightConeLift] = 0;
	motor[leftConeLift] = 0;
}

void openClaw(){
	motor[claw] = 75;
}
void closeClaw(){
	motor[claw] = -75;
}
void lockClaw(){
	motor[claw] = -50;
}
void stopClaw(){
	motor[claw] = 0;
}

void clawForward(){
	motor[tiltClaw] = 127;
}
void clawBackward(){
	motor[tiltClaw] = -127;
}
void stopTilt(){
	motor[tiltClaw] = 0;
}

int inchesToTicks(float inches){
	float numberOfRotations = inches / (2.0 * PI * 4.0);
	int numTicks = numberOfRotations * 90;
	return numTicks;
}

//////////////////////////////////////////////////////////////
// Apply an exponential transformation to the joystick,     //
// allowing for fine control at low values while still      //
// providing full speed control.                            //
//                                                          //
// Motor Speed = 14.1111 * (10^(Input Value/127)) - 14.1111 //
//////////////////////////////////////////////////////////////
int transformJoystick(int joyValue){
	if (abs(joyValue) < deadzone){
		return 0;
	}

	bool isPositive = true;
	if (joyValue < 0){
		isPositive = false;
	}

	int finalSpeed = (127.0/9.0) * pow(10.0, (abs(joyValue) / 127.0)) - (127.0/9.0);

	if (!isPositive){
		finalSpeed *= -1;
	}
	return finalSpeed;
}

//////////////////////////////////////////
// Conversions for Claw Tilt Controller //
//////////////////////////////////////////

int clawTiltEncoderToLiftEncoder(int clawTiltValue){
	int convertedValue = (1960.0 * clawTiltValue) / 180;
	return convertedValue;
}

/*-----PID Lift Control-----*/
/*
typedef struct{
	int leftMGLTarget;
	int rightMGLTarget;
} mglPos;

mglPos top = {293, 3810};
mglPos bottom = {1478, 2378};
mglPos lowBar = {1460, 2529};

mglPos nextPos = bottom;
*/

#define LEFT_MGL_BOTTOM  1478;
#define RIGHT_MGL_BOTTOM  2378;

#define LEFT_MGL_TOP  293;
#define RIGHT_MGL_TOP  3810;

#define LEFT_MGL_LOW_BAR 1340
#define RIGHT_MGL_LOW_BAR  2740

#define LEFT_MGL_HIGH_BAR 1116
#define RIGHT_MGL_HIGH_BAR 2900


int leftMGLTarget = LEFT_MGL_TOP;
int rightMGLTarget = RIGHT_MGL_TOP;

task mglControl(){
	mglPControlIsRunning = true;
	while (true){
		rightMGLAngle = SensorValue(rightMGL);
		leftMGLAngle = SensorValue(leftMGL);

		rightMGLError = -1 * (rightMGLAngle - rightMGLTarget);
		//leftMGLError = leftMGLAngle - leftMGLTarget;

		rightMGLSpeed = kpMglLift * rightMGLError;
		leftMGLSpeed = kpMglLift * rightMGLError;

		if (leftMGLSpeed > 80){
			leftMGLSpeed = 80;
		}
		if (leftMGLSpeed < -40){
			leftMGLSpeed = -40;
		}

		if (rightMGLSpeed > 80){
			rightMGLSpeed = 80;
		}
		if (rightMGLSpeed < -40){
			rightMGLSpeed = -40;
		}

		motor[leftMGLift] = leftMGLSpeed;
		motor[rightMGLift] = rightMGLSpeed;

		sleep(20);
	}
}

task liftControl(){
	tiltAngle = -1 * clawTiltEncoderToLiftEncoder(SensorValue(clawTiltAngle));
	liftAngle = SensorValue(leftLift);
/*
	if (keepClawLevel){
		clawTarget = liftAngle;
	}*/

	startErrorClaw = liftAngle - tiltAngle;
	pControlIsRunning = true;

	while (true){
		tiltAngle = -1 * clawTiltEncoderToLiftEncoder(SensorValue(clawTiltAngle));
		if (keepClawLevel){
			clawTarget = SensorValue(leftLift) - startErrorClaw;
		}
		clawError = tiltAngle - clawTarget;
		liftError = liftAngle - liftTarget;

		liftMotorSpeed = kpLift * liftError;
		tiltMotorSpeed = kpClaw * clawError;

		if (tiltMotorSpeed > 127){
			tiltMotorSpeed = 127;
		}
		else if (tiltMotorSpeed < -127){
			tiltMotorSpeed = -127;
		}

		if (liftMotorSpeed > 127){
			liftMotorSpeed = 127;
		}
		else if (tiltMotorSpeed < -127){
			liftMotorSpeed = -127;
		}

		motor[tiltClaw] = tiltMotorSpeed;
		motor[leftConeLift] = liftMotorSpeed;
		motor[rightConeLift] = liftMotorSpeed;

		sleep(20);
	}
}

float inchesToDrive = 0.0;

int leftDTTarget;
int rightDTTarget;

int leftDTPos;
int rightDTPos;
int leftDTError;
int rightDTError;
int leftDTSpeed;
int rightDTSpeed;
float kpDt = 0.0;

task driveControl(){
	leftDTPos = SensorValue(leftDT);
	rightDTPos = SensorValue(rightDTPos);

	leftDTTarget = leftDTPos + inchesToTicks(inchesToDrive);
	rightDTTarget = rightDTPos + inchesToTicks(inchesToDrive);

	while (true){
		leftDTPos = SensorValue(leftDT);
		rightDTPos = SensorValue(rightDT);

		leftDTError = leftDTTarget - leftDTPos + (rightDTPos - leftDTPos);
		rightDTError = rightDTTarget - rightDTPos;

		leftDTSpeed = kpDt * leftDTError;
		rightDTSpeed = kpDt * rightDTError;

		if (leftDTSpeed > 127){
			leftDTSpeed = 127;
		}
		if (leftDTSpeed < -127){
			leftDTSpeed = -127;
		}

		if (rightDTSpeed > 100){
			rightDTSpeed = 100;
		}
		if (rightDTSpeed < -100){
			leftDTSpeed = -100;
		}

		motor[frontLeftDT] = leftDTSpeed;
		motor[backLeftDT] = leftDTSpeed;

		motor[frontRightDT] = rightDTSpeed;
		motor[backRightDT] = rightDTSpeed;

		if (abs(leftDTError) < 10 && abs(rightDTError) < 10){
			break;
		}

		sleep(20);
	}
}

/*-----Autonomous-----*/

int autonomousMode = 0;

task autonomous()
{
	playSoundFile("music.wav");
<<<<<<< HEAD
	motor[frontLeftDT] = 127;
	motor[backLeftDT] = 127;

	motor[frontRightDT] = 127;
	motor[backRightDT] = 127;

	wait1Msec(4300);

	motor[frontLeftDT] = 0;
	motor[backLeftDT] = 0;

	motor[frontRightDT] = 0;
	motor[backRightDT] = 0;

/*playSoundFile("music.wav");
	lockClaw();
	raiseConeLift();
	while (SensorValue[rightLift] < 500){}
	stopConeLift();

	lowerMGLift();
	while (SensorValue[mglLeft] > mglMin){}
	stopMGLift();

	motor[frontRightDT] = 127;
	motor[frontLeftDT] = 72;
	motor[backRightDT] = 127;
	motor[backLeftDT] = 72;
	wait1Msec(2500);
	motor[frontRightDT] = 0;
	motor[frontLeftDT] = 0;

	motor[backRightDT] = 0;
	motor[backLeftDT] = 0;

	lowerConeLift();
	while (SensorValue[rightLift] > 200){}
	stopConeLift();

	openClaw();
	wait1Msec(500);
	stopClaw();

	raiseConeLift();
	while (SensorValue[rightLift] < 500){}
	stopConeLift();

	motor[frontRightDT] = -50;
	motor[frontLeftDT] = -50;

	motor[backRightDT] = -50;
	motor[backLeftDT] = -50;
	wait1Msec(1000);

	motor[frontRightDT] = 0;
	motor[frontLeftDT] = 0;

	motor[backRightDT] = 0;
	motor[backLeftDT] = 0;*/
=======

	if (autonomousMode == 1){}

	if (autonomousMode == 2){}

	if (autonomousMode == 3){}

	if (autonomousMode == 4){}

	if (autonomousMode == 5){}

	if (autonomousMode == 6){}

>>>>>>> 6a2d3c03272651c862c30c8c9c012e92b8cfbc0e
}

/*-----Driver Control-----*/
task usercontrol()
{
<<<<<<< HEAD
	//startTask(liftControl);
=======
	startTask(liftControl);
	startTask(mglControl);
>>>>>>> 6a2d3c03272651c862c30c8c9c012e92b8cfbc0e
	while (true)
	{
		int leftStick = transformJoystick(vexRT[Ch3]);
		int rightStick = transformJoystick(vexRT[Ch2]);

		motor[frontLeftDT] = leftStick;
		motor[backLeftDT] = leftStick;

		motor[frontRightDT] = rightStick;
		motor[backRightDT] = rightStick;

		if (vexRT[Btn5U] == 1){
<<<<<<< HEAD
			raiseMGLift();
		}
		else if (vexRT[Btn5D] == 1){
			lowerMGLift();
		}
		else if (vexRT[Btn8D] == 1){
=======
			if (mglPControlIsRunning){
				stopTask(mglControl);
				mglPControlIsRunning = false;
			}
			raiseMGLift();
		}
		else if (vexRT[Btn5D] == 1){
			if (mglPControlIsRunning){
				stopTask(mglControl);
				mglPControlIsRunning = false;
			}
>>>>>>> 6a2d3c03272651c862c30c8c9c012e92b8cfbc0e
			lowerMGLift();
		}

		else{
			if (!mglPControlIsRunning){
				if (mglAllowPControl){
					startTask(mglControl);
				}
				else{
					stopMGLift();
				}
			}
		}

		if (vexRT[Btn6D] == 1){
			raiseConeLift();
		}

		if (vexRT[Btn6U] == 1){
			lowerConeLift();
		}

		if (vexRT[Btn6U] == 0 && vexRT[Btn6D] == 0) {
			stopConeLift();
		}

		if (vexRT[Btn7UXmtr2] == 1){
			openClaw();
			clawLocked = false;
		}
		else if (vexRT[Btn7LXmtr2] == 1){
			closeClaw();
			clawLocked = false;
		}
		else if (vexRT[Btn7RXmtr2] == 1 && !btn7ROld){
			btn7ROld = true;
			if (!clawLocked){
				clawLocked = true;
				lockClaw();
			}
			else{
				clawLocked = false;
			}
		}
		else if (!clawLocked) {
			stopClaw();
		}

		if (vexRT[Btn7R] == 0){
			btn7ROld = false;
		}

		// Stop/Start P-Control

		if (vexRT[Btn8DXmtr2] == 1 && !Btn8DXmtr2Old){
			Btn8DXmtr2Old = true;
			if (pControlIsRunning){
				stopTask(liftControl);
				pControlIsRunning = false;
				allowPControl = false;
			}
			else{
				startTask(liftControl);
				allowPControl = true;
			}
		}

		if (vexRT[Btn8DXmtr2] == 0 && Btn8DXmtr2Old){
			Btn8DXmtr2Old = false;
		}

		// Manually override claw tilt p-control
		if (vexRT[Btn6UXmtr2] == 1){
			if (pControlIsRunning){
				stopTask(liftControl);
				pControlIsRunning = false;
			}
			clawForward();
		}
		else if (vexRT[Btn6DXmtr2] == 1){
			if (pControlIsRunning){
				stopTask(liftControl);
				pControlIsRunning = false;
			}
			clawBackward();
		}
		else{
			if (allowPControl && !pControlIsRunning){
				startTask(liftControl);
			}
			if (!allowPControl){
				stopTilt();
			}
		}
	}
}
